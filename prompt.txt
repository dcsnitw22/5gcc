As you know this is my ultimate goal: 
I want you to implement tracing for release function.

Below order should be followed:
1.Routes() in api.go
2.UpdateSmContext() in api.go
3. handlePdusmspEvents() in pdusmsp.go
4.dispatchWork() in pdusmsp.go
5. ProcessNsmfUpdateSmContextRequest() in sm.go
IMP NOTE: Inside the function there is an if condition, that separates update and release.

After going through the first round of changes, I have implemented those changes in my code and getting few errors while performing the update function.

Again please have a look at the order in which I am looking to have tracing implemented for update.

First I will share the error that I have received and then i will share my updated code files with you:

This is the error:

I0204 09:38:39.344969       7 api.go:447] Inside UpdateSmContext
I0204 09:38:39.345000       7 api.go:448] Update SM Context is being processed
I0204 09:38:39.347477       7 api.go:464] Json data is:{
    "pei": "280129383791827",
    "servingNfId": "3fa85f64-5717-4562-nwi3-2c963f66afa6",
    "guami": {
        "plmnId": {
            "mcc": "404",
            "mnc": "10"
        },
        "amfId": "218A9E"
    },
    "servingNetwork": {
        "mcc": "404",
        "mnc": "10"
    },
    "backupAmfInfo": [
        {
            "backupAmf": "218A9F",
            "guamiList": [
                {
                    "plmnId": {
                        "mcc": "404",
                        "mnc": "10"
                    },
                    "amfId": "1927AE"
                }
            ]
        }
    ],
    "anType": "3GPP_ACCESS",
    "ratType": "NR",
    "ueLocation": {
        "eutraLocation": {
            "tai": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "tac": " 63F84B"
            },
            "ecgi": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "eutraCellId": "5BD6007"
            },
            "ageOfLocationInformation": 32767,
            "ueLocationTimestamp": "2023-07-03T20:24:16.446Z",
            "geographicalInformation": "5BD600822D6008",
            "geodeticInformation": "5BD600822D60081234",
            "globalNgenbId": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "n3IwfId": "A2139",
                "gNbId": {
                    "bitLength": 32,
                    "gNBValue": "12345999"
                },
                "ngeNbId": "SMacroNGeNB-34B89"
            }
        },
        "nrLocation": {
            "tai": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "tac": "63F84B"
            },
            "ncgi": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "nrCellId": "225BD6007"
            },
            "ageOfLocationInformation": 32767,
            "ueLocationTimestamp": "2023-07-03T20:24:16.446Z",
            "geographicalInformation": "5BD600822D6009",
            "geodeticInformation": "5BD600822D60081230",
            "globalGnbId": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "n3IwfId": "87878756",
                "gNbId": {
                    "bitLength": 32,
                    "gNBValue": "12345999"
                },
                "ngeNbId": "SMacroNGeNB-34B89"
            }
        },
        "n3gaLocation": {
            "n3gppTai": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "tac": "63F84B"
            },
            "n3IwfId": "87878756",
            "ueIpv4Addr": "198.51.100.1",
            "ueIpv6Addr": "2001:db8:85a3::8a2e:370:7334",
            "portNumber": 0
        }
    },
    "ueTimeZone": "+02:00",
    "addUeLocation": {
        "eutraLocation": {
            "tai": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "tac": "63F84B"
            },
            "ecgi": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "eutraCellId": "5BD6007"
            },
            "ageOfLocationInformation": 32767,
            "ueLocationTimestamp": "2023-07-03T20:24:16.446Z",
            "geographicalInformation": "5BD600822D6009",
            "geodeticInformation": "5BD600822D60081230",
            "globalNgenbId": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "n3IwfId": "87878756",
                "gNbId": {
                    "bitLength": 32,
                    "gNBValue": "12345999"
                },
                "ngeNbId": "SMacroNGeNB-34B89"
            }
        },
        "nrLocation": {
            "tai": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "tac": "63F84B"
            },
            "ncgi": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "nrCellId": "225BD6007"
            },
            "ageOfLocationInformation": 32767,
            "ueLocationTimestamp": "2023-07-03T20:24:16.446Z",
            "geographicalInformation": "5BD600822D6008",
            "geodeticInformation": "5BD600822D60081230",
            "globalGnbId": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "n3IwfId": "87878756",
                "gNbId": {
                    "bitLength": 32,
                    "gNBValue": "12345999"
                },
                "ngeNbId": "SMacroNGeNB-34B89"
            }
        },
        "n3gaLocation": {
            "n3gppTai": {
                "plmnId": {
                    "mcc": "404",
                    "mnc": "10"
                },
                "tac": "63F84B"
            },
            "n3IwfId": "87878756",
            "ueIpv4Addr": "198.51.100.1",
            "ueIpv6Addr": "2001:db8:85a3::8a2e:370:7334",
            "portNumber": 0
        }
    },
    "toBeSwitched": false,
    "failedToBeSwitched": true,
    "n1SmMsg": {
        "contentId": "n1smmsg27183"
    },
    "n2SmInfo": {
        "contentId": "n2sminfo10296"
    },
    "targetId": {
        "ranNodeId": {
            "plmnId": {
                "mcc": "404",
                "mnc": "10"
            },
            "n3IwfId": "17263",
            "gNbId": {
                "bitLength": 22,
                "gNBValue": "2A3F47"
            },
            "ngeNbId": "SMacroNGeNB-34B89"
        },
        "tai": {
            "plmnId": {
                "mcc": "404",
                "mnc": "10"
            },
            "tac": "63F84B"
        }
    },
    "targetServingNfId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "smContextStatusUri": "https://example.com/notify/smcontextstatus",
    "dataForwarding": false,
    "epsBearerSetup": [
        "string"
    ],
    "revokeEbiList": [
        15
    ],
    "release": false,
    "ngApCause": {
        "group": 1,
        "value": 1
    },
    "5gMmCauseValue": 0,
    "sNssai": {
        "sst": 255,
        "sd": "123456"
    },
    "anTypeCanBeChanged": false,
    "n2SmInfoExt1": {
        "contentId": "n2sminfoext109172"
    }
}
I0204 09:38:39.347528       7 api.go:465] Input data is : {Pei:280129383791827 ServingNfId:3fa85f64-5717-4562-nwi3-2c963f66afa6 Guami:{PlmnId:{Mcc:404 Mnc:10} AmfId:218A9E} ServingNetwork:{Mcc:404 Mnc:10} BackupAmfInfo:0xc000012a20 AnType:3GPP_ACCESS RatType:NR PresenceInLadn:{} UeLocation:{EutraLocation:{Tai:{PlmnId:{Mcc:404 Mnc:10} Tac: 63F84B} Ecgi:{PlmnId:{Mcc:404 Mnc:10} EutraCellId:5BD6007} AgeOfLocationInformation:32767 UeLocationTimestamp:2023-07-03 20:24:16.446 +0000 UTC GeographicalInformation:5BD600822D6008 GeodeticInformation:5BD600822D60081234 GlobalNgenbId:0xc000154d20} NrLocation:{Tai:{PlmnId:{Mcc:404 Mnc:10} Tac:63F84B} Ncgi:{PlmnId:{Mcc:404 Mnc:10} NrCellId:225BD6007} AgeOfLocationInformation:32767 UeLocationTimestamp:2023-07-03 20:24:16.446 +0000 UTC GeographicalInformation:5BD600822D6009 GeodeticInformation:5BD600822D60081230 GlobalGnbId:0xc000154d80} N3gaLocation:{N3gppTai:{PlmnId:{Mcc:404 Mnc:10} Tac:63F84B} N3IwfId:87878756 UeIpv4Addr:198.51.100.1 UeIpv6Addr:2001:db8:85a3::8a2e:370:7334 PortNumber:0}} UeTimeZone:+02:00 AddUeLocation:{EutraLocation:{Tai:{PlmnId:{Mcc:404 Mnc:10} Tac:63F84B} Ecgi:{PlmnId:{Mcc:404 Mnc:10} EutraCellId:5BD6007} AgeOfLocationInformation:32767 UeLocationTimestamp:2023-07-03 20:24:16.446 +0000 UTC GeographicalInformation:5BD600822D6009 GeodeticInformation:5BD600822D60081230 GlobalNgenbId:0xc000154de0} NrLocation:{Tai:{PlmnId:{Mcc:404 Mnc:10} Tac:63F84B} Ncgi:{PlmnId:{Mcc:404 Mnc:10} NrCellId:225BD6007} AgeOfLocationInformation:32767 UeLocationTimestamp:2023-07-03 20:24:16.446 +0000 UTC GeographicalInformation:5BD600822D6008 GeodeticInformation:5BD600822D60081230 GlobalGnbId:0xc000154e40} N3gaLocation:{N3gppTai:{PlmnId:{Mcc:404 Mnc:10} Tac:63F84B} N3IwfId:87878756 UeIpv4Addr:198.51.100.1 UeIpv6Addr:2001:db8:85a3::8a2e:370:7334 PortNumber:0}} UpCnxState:0 HoState:{} ToBeSwitched:false FailedToBeSwitched:true N1SmMsg:{ContentId:n1smmsg27183} N2SmInfo:{ContentId:n2sminfo10296} N2SmInfoType:{} TargetId:{RanNodeId:0xc000154ea0 Tai:{PlmnId:{Mcc:404 Mnc:10} Tac:63F84B}} TargetServingNfId:3fa85f64-5717-4562-b3fc-2c963f66afa6 SmContextStatusUri:https://example.com/notify/smcontextstatus DataForwarding:false EpsBearerSetup:[string] RevokeEbiList:[15] Release:false Cause:{} NgApCause:{Group:1 Value:1} Var5gMmCauseValue:0 SNssai:{Sst:255 Sd:123456} TraceData:<nil> EpsInterworkingInd: AnTypeCanBeChanged:false N2SmInfoExt1:{ContentId:n2sminfoext109172} N2SmInfoTypeExt1:{}}
I0204 09:38:39.347763       7 api.go:478] Data Checks passed
I0204 09:38:39.347781       7 api.go:490] Binary Data: []
I0204 09:38:39.347797       7 api.go:501] Binary Data: []
I0204 09:38:39.347811       7 api.go:513] Binary Data: []
I0204 09:38:39.347839       7 pdusmsp.go:226] handlePdusmspEvents (UPDATE SM CONTEXT  REQUEST)
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0xf8 pc=0xfc7661]
goroutine 1 [running]:
net/http.(*Request).Context(...)
	net/http/request.go:352
w5gc.io/wipro5gcore/pkg/smf/pdusmsp.(*Pdusmsp).handlePdusmspEvents(0xc0001ca0b0, 0x0?, 0xc000454070, 0xc0004b83f0, 0xc0004b8460, 0xc0004b8540, {0x148c2a0, 0xc0001ca0b0})
	w5gc.io/wipro5gcore/pkg/smf/pdusmsp/pdusmsp.go:242 +0x201
w5gc.io/wipro5gcore/pkg/smf/pdusmsp.(*Pdusmsp).pdusmspEvents(0xc0001ca0b0, 0xc00056e0e0, {0x148c2a0, 0xc0001ca0b0})
	w5gc.io/wipro5gcore/pkg/smf/pdusmsp/pdusmsp.go:160 +0x145
w5gc.io/wipro5gcore/pkg/smf/pdusmsp.(*Pdusmsp).Run(0xc0001ca0b0, 0xc00056e0e0)
	w5gc.io/wipro5gcore/pkg/smf/pdusmsp/pdusmsp.go:147 +0x171
w5gc.io/wipro5gcore/cmd/smf/pdusmsp/app.RunPdusmsp({0x0, 0x0}, {0x0, 0x0}, {0x0, 0x0}, 0x0)
	w5gc.io/wipro5gcore/cmd/smf/pdusmsp/app/server.go:34 +0x194
w5gc.io/wipro5gcore/cmd/smf/pdusmsp/app.NewPdusmspRootCommand.func1(0xc0004a6800?, {0x12eaac0?, 0x4?, 0x12eaac4?})
	w5gc.io/wipro5gcore/cmd/smf/pdusmsp/app/root.go:19 +0x3d
github.com/spf13/cobra.(*Command).execute(0xc000352008, {0xc0000401c0, 0x0, 0x0})
	github.com/spf13/cobra@v1.7.0/command.go:944 +0x847
github.com/spf13/cobra.(*Command).ExecuteC(0xc000352008)
	github.com/spf13/cobra@v1.7.0/command.go:1068 +0x3a5
github.com/spf13/cobra.(*Command).Execute(0x4799ba?)
	github.com/spf13/cobra@v1.7.0/command.go:992 +0x13
main.main()
	w5gc.io/wipro5gcore/cmd/smf/pdusmsp/pdusmsp.go:12 +0x18


Now I will share my updated code files

This is my api.go file:

package api


import (
   "context"
   "encoding/json"
   "io/ioutil"
   "net/http"
   "strings"
   "time"


   //"net"


   "github.com/gorilla/mux"
   "k8s.io/klog"


   //"w5gc.io/wipro5gcore/openapi"
   "w5gc.io/wipro5gcore/openapi/openapiserver"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/config"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/sm"


   //"net"


   //"w5gc.io/wipro5gcore/openapi"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/tracing"
   // "go.opentelemetry.io/otel/attribute"
   // "go.opentelemetry.io/otel/trace"
   "go.opentelemetry.io/otel/codes"
)


const (
   ApiChannelCapacity = 100
)


type SessionMessage struct {
   MsgType                       sm.MessageType
   SessionMsg                    sm.SMContextMessage
   SmContextRefID                string
   BinaryDataN1SmMessage         []byte
   BinaryDataN2SmInformation     []byte
   BinaryDataN2SmInformationExt1 []byte
   Writer                        http.ResponseWriter
   Request                       *http.Request
   Ctx                           context.Context
}


type Receiver struct {
   RecievedResponse openapiserver.ImplResponse
   RecievedErr      error
}


type ApiServer interface {
   Start()
   WatchApiChannel() chan *SessionMessage
   WatchRecChannel() chan *Receiver
}


type ApiServerInfo struct {
   serverStartTime time.Time
   apiChannel      chan *SessionMessage
   apiReceiver     chan *Receiver
   //  router          http.Handler
   nodeInfo        config.SmfNodeInfo
   RequestResponse openapiserver.ImplResponse
   ErrorResponse   error


   // individualController *IndividualSMContextAPIController
   // collectionController *SMContextsCollectionAPIController
}


// Added --> Including code from api files generated
// SMContextsCollectionAPIController binds http requests to an api service and writes the service results to the http response
// type SMContextsCollectionAPIController struct {
//  service      openapiserver.SMContextsCollectionAPIServicer
//  errorHandler openapiserver.ErrorHandler
// }


// SMContextsCollectionAPIOption for how the controller is set up.
//type SMContextsCollectionAPIOption func(*SMContextsCollectionAPIController)


// IndividualSMContextAPIController binds http requests to an api service and writes the service results to the http response
// type IndividualSMContextAPIController struct {
//  service      openapiserver.IndividualSMContextAPIServicer
//  errorHandler openapiserver.ErrorHandler
// }


// IndividualSMContextAPIOption for how the controller is set up.
//type IndividualSMContextAPIOption func(*IndividualSMContextAPIController)


func NewApiServer(cfg config.SmfNodeInfo) ApiServer {
   //Commented by Mounika --> PDU Session will be handled by HSMF and ISMF
   //      IndividualPDUSessionHSMFAPIService := NewIndividualPDUSessionHSMFAPIService()
   //      IndividualPDUSessionHSMFAPIController := NewIndividualPDUSessionHSMFAPIController(IndividualPDUSessionHSMFAPIService)


   // IndividualSMContextAPIService := openapiserver.NewIndividualSMContextAPIService()
   // IndividualSMContextAPIController := NewIndividualSMContextAPIController(IndividualSMContextAPIService)


   //      PDUSessionsCollectionAPIService := NewPDUSessionsCollectionAPIService()
   //      PDUSessionsCollectionAPIController := NewPDUSessionsCollectionAPIController(PDUSessionsCollectionAPIService)


   // SMContextsCollectionAPIService := openapiserver.NewSMContextsCollectionAPIService()
   // SMContextsCollectionAPIController := NewSMContextsCollectionAPIController(SMContextsCollectionAPIService)


   //router := NewRouter(
   //              IndividualPDUSessionHSMFAPIController,
   //  IndividualSMContextAPIController,
   //              PDUSessionsCollectionAPIController,
   //  SMContextsCollectionAPIController,
   //)


   return &ApiServerInfo{
       //  router:     router,
       nodeInfo:    cfg,
       apiChannel:  make(chan *SessionMessage, ApiChannelCapacity),
       apiReceiver: make(chan *Receiver),
       //      individualController: IndividualSMContextAPIController,
       //      collectionController: SMContextsCollectionAPIController,
   }
}


// func GetResponse(resp openapiserver.ImplResponse,err error)


func (a *ApiServerInfo) Start() {
   klog.Infof("Started SMF pdusmsp API server")
   router := NewRouter(a.Routes())
   klog.Infof("Started the server on Port: %v", a.nodeInfo.ApiPort)
   klog.Fatal(http.ListenAndServe(a.nodeInfo.ApiPort, router))


}


// Following code added from generated code


// NewIndividualSMContextAPIController creates a default api controller
// func NewIndividualSMContextAPIController(s openapiserver.IndividualSMContextAPIServicer, opts ...IndividualSMContextAPIOption) Router {
//  controller := &IndividualSMContextAPIController{
//      service:      s,
//      errorHandler: openapiserver.DefaultErrorHandler,
//  }


//  for _, opt := range opts {
//      opt(controller)
//  }


//  return controller
// }


// NewSMContextsCollectionAPIController creates a default api controller
// func NewSMContextsCollectionAPIController(s openapiserver.SMContextsCollectionAPIServicer, opts ...SMContextsCollectionAPIOption) Router {
//  controller := &SMContextsCollectionAPIController{
//      service:      s,
//      errorHandler: openapiserver.DefaultErrorHandler,
//  }


//  for _, opt := range opts {
//      opt(controller)
//  }


//  return controller
// }


// Routes returns all the api routes for the SMContextsCollectionAPIController
func (a *ApiServerInfo) Routes() Routes {
   return Routes{
       "PostSmContexts": Route{
           strings.ToUpper("Post"),
           "/nsmf-pdusession/v1/sm-contexts",
           a.PostSmContexts,
       },
       "ReleaseSmContext": Route{
           strings.ToUpper("Post"),
           "/nsmf-pdusession/v1/sm-contexts/{smContextRef}/release",
           a.ReleaseSmContext,
       },
       "RetrieveSmContext": Route{
           strings.ToUpper("Post"),
           "/nsmf-pdusession/v1/sm-contexts/{smContextRef}/retrieve",
           a.RetrieveSmContext,
       },
       "UpdateSmContext": Route{
           strings.ToUpper("Post"),
           "/nsmf-pdusession/v1/sm-contexts/{smContextRef}/modify",
           a.UpdateSmContext,
       },
   }
}


// PostSmContexts - Create SM Context
func (a *ApiServerInfo) PostSmContexts(w http.ResponseWriter, r *http.Request) {
   klog.Info("Inside PostSmContexts function")


   // Ensure the request is not nil
   if r == nil {
       klog.Errorf("Request is nil")
       http.Error(w, "Internal Server Error", http.StatusInternalServerError)
       return
   }


   ctx, span := tracing.Tracer.Start(r.Context(), "PostSmContexts")
   defer span.End()
   //validate whether amf node ip is present or not
   //remove ip check we will di amfi check
   // AmfNodeIPAddress := r.Header.Get("X-Real-Ip")
   // if AmfNodeIPAddress == "" {
   //  AmfNodeIPAddress = r.Header.Get("X-Forwarded-For")
   // }
   // if AmfNodeIPAddress == "" {
   //  AmfNodeIPAddress = r.RemoteAddr
   // }
   // AmfNodeIPAddress = strings.Split(AmfNodeIPAddress, ":")[0]
   // N11AmfNodes := (config.PdusmspCfg).N11AmfNodes
   // found := false
   // klog.Info(N11AmfNodes)
   // for i := 0; i < len(N11AmfNodes); i++ {
   //  klog.Info(N11AmfNodes[i].NodeId)
   //  if AmfNodeIPAddress == N11AmfNodes[i].NodeId {
   //      found = true
   //      break
   //  }
   // }
   // klog.Info(found)
   // if !found {
   //  klog.Info("Request has not been sent from a peer AMF node")
   //  err := errors.New("request has not been sent from a peer amf node")
   //  // klog.Infof("writer: %v,\n request: %v,\n error: %v\n", w, r, err)
   //  openapiserver.DefaultErrorHandler(w, r, err, &openapiserver.ImplResponse{
   //      Code: http.StatusBadRequest,
   //      Body: err.Error(),
   //  })
   //  return
   // }


   klog.Info("Creating SMContext")
   if err := r.ParseMultipartForm(32 << 20); err != nil {
       //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   jsonDataParam := r.FormValue("jsonData")


   //Next two lines are added by Mounika --> To convert json data into struct
   smContextCreateDataParam := openapiserver.SmContextCreateData{
       HTTPRequest: r.WithContext(ctx),
   }


   klog.Info(json.Unmarshal([]byte(jsonDataParam), &smContextCreateDataParam))
   klog.Infof("Json data is:%v", jsonDataParam)
   klog.Infof("Input data is : %+v", smContextCreateDataParam)


   if err := openapiserver.AssertSmContextCreateDataRequired(smContextCreateDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   if err := openapiserver.AssertSmContextCreateDataConstraints(smContextCreateDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   klog.Infof("Data Checks passed")
   //added by Ruchi
   //nasMsgParam := r.FormValue("binaryDataN1SmMessage")
   //var binaryDataN1SmMessageParam []byte
   //json.Unmarshal([]byte(nasMsgParam), &binaryDataN1SmMessageParam)


   _, fileHeader, err := r.FormFile("binaryDataN1SmMessage")
   if err != nil {
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   formFile, err := fileHeader.Open()
   if err != nil {
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   defer formFile.Close()
   binaryDataN1SmMessageParam, err := ioutil.ReadAll(formFile)
   if err != nil {
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   // binaryDataN1SmMessageParam, err := ReadFormFileToTempFile(r, "binaryDataN1SmMessage")
   // if err != nil {
   //  //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  return
   // }
   klog.Infof("Binary Data: %v", binaryDataN1SmMessageParam)
   //send writer in channel
   a.apiChannel <- &SessionMessage{
       Ctx:                           ctx,
       MsgType:                       sm.NSMF_CREATE_SM_CONTEXT_REQUEST,
       SessionMsg:                    smContextCreateDataParam,
       SmContextRefID:                "",
       BinaryDataN2SmInformation:     nil,
       BinaryDataN1SmMessage:         binaryDataN1SmMessageParam,
       BinaryDataN2SmInformationExt1: nil,
       Writer:                        w,
       Request:                       r.WithContext(ctx),
   }


   //TODO make a reciever function using code written below
   rec := <-a.apiReceiver
   // klog.Info(rec)


   if rec.RecievedErr != nil {
       openapiserver.DefaultErrorHandler(
           w, r, &openapiserver.ParsingError{
               Err: rec.RecievedErr,
           }, &rec.RecievedResponse,
       )
       return
   }
   EncodeJSONResponse(rec.RecievedResponse.Body, &rec.RecievedResponse.Code, w)
   span.SetStatus(codes.Ok, "Successfully processed PostSmContexts")
}


// ReleaseSmContext - Release SM Context
func (a *ApiServerInfo) ReleaseSmContext(w http.ResponseWriter, r *http.Request) {
   klog.Info("Inside ReleaseSmContext function")


   params := mux.Vars(r)
   smContextRefParam := params["smContextRef"]


   if err := r.ParseMultipartForm(32 << 20); err != nil {
       //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   jsonDataParam := r.FormValue("jsonData")


   smContextReleaseDataParam := openapiserver.SmContextReleaseData{}


   json.Unmarshal([]byte(jsonDataParam), &smContextReleaseDataParam)


   klog.Infof("Json data is:%v", jsonDataParam)
   klog.Infof("Input data is : %+v", smContextReleaseDataParam)


   if err := openapiserver.AssertSmContextReleaseDataRequired(smContextReleaseDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   if err := openapiserver.AssertSmContextReleaseDataConstraints(smContextReleaseDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   klog.Infof("Data Checks passed")


   // binaryDataN2SmInformationParam, err := ReadFormFileToTempFile(r, "binaryDataN2SmInformation")
   // if err != nil {
   //  //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  return
   // }


   nasMsgParam := r.FormValue("binaryDataN2SmInformation")
   var binaryDataN2SmInformationParam []byte
   json.Unmarshal([]byte(nasMsgParam), &binaryDataN2SmInformationParam)
   klog.Infof("Binary Data: %v", binaryDataN2SmInformationParam)


   a.apiChannel <- &SessionMessage{
       MsgType:                       sm.NSMF_RELEASE_SM_CONTEXT_REQUEST,
       SessionMsg:                    smContextReleaseDataParam,
       SmContextRefID:                smContextRefParam,
       BinaryDataN2SmInformation:     binaryDataN2SmInformationParam,
       BinaryDataN1SmMessage:         nil,
       BinaryDataN2SmInformationExt1: nil}
   //TODO  create a function to handle situation below
   rec := <-a.apiReceiver
   // klog.Info(rec)


   if rec.RecievedErr != nil {
       openapiserver.DefaultErrorHandler(
           w, r, &openapiserver.ParsingError{
               Err: rec.RecievedErr,
           }, &rec.RecievedResponse,
       )
       return
   }
   EncodeJSONResponse(rec.RecievedResponse.Body, &rec.RecievedResponse.Code, w)


}


// RetrieveSmContext - Retrieve SM Context
func (a *ApiServerInfo) RetrieveSmContext(w http.ResponseWriter, r *http.Request) {
   klog.Info("Inside RetrieveSMContext function")
   params := mux.Vars(r)
   smContextRefParam := params["smContextRef"]
   smContextRetrieveDataParam := openapiserver.SmContextRetrieveData{}
   d := json.NewDecoder(r.Body)
   d.DisallowUnknownFields()
   if err := d.Decode(&smContextRetrieveDataParam); err != nil {
       //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   klog.Infof("Input data is: %+v", smContextRetrieveDataParam)
   if err := openapiserver.AssertSmContextRetrieveDataRequired(smContextRetrieveDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   if err := openapiserver.AssertSmContextRetrieveDataConstraints(smContextRetrieveDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   klog.Infof("Data Checks passed")


   a.apiChannel <- &SessionMessage{MsgType: sm.NSMF_RETRIEVE_SM_CONTEXT_REQUEST,
       SessionMsg:                smContextRetrieveDataParam,
       SmContextRefID:            smContextRefParam,
       BinaryDataN2SmInformation: nil,
       BinaryDataN1SmMessage:     nil, BinaryDataN2SmInformationExt1: nil}
   rec := <-a.apiReceiver
   // klog.Info(rec)


   if rec.RecievedErr != nil {
       openapiserver.DefaultErrorHandler(
           w, r, &openapiserver.ParsingError{
               Err: rec.RecievedErr,
           }, &rec.RecievedResponse,
       )
       return
   }
   EncodeJSONResponse(rec.RecievedResponse.Body, &rec.RecievedResponse.Code, w)


}


// UpdateSmContext - Update SM Context
func (a *ApiServerInfo) UpdateSmContext(w http.ResponseWriter, r *http.Request) {


   ctx, span := tracing.Tracer.Start(r.Context(), "UpdateSmContext")
   defer span.End()


   klog.Info("Inside UpdateSmContext")
   klog.Info("Update SM Context is being processed")
   params := mux.Vars(r)
   smContextRefParam := params["smContextRef"]


   if err := r.ParseMultipartForm(32 << 20); err != nil {
       //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   jsonDataParam := r.FormValue("jsonData")


   smContextUpdateDataParam := openapiserver.SmContextUpdateData{}


   json.Unmarshal([]byte(jsonDataParam), &smContextUpdateDataParam)


   klog.Infof("Json data is:%v", jsonDataParam)
   klog.Infof("Input data is : %+v", smContextUpdateDataParam)


   if err := openapiserver.AssertSmContextUpdateDataRequired(smContextUpdateDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }
   if err := openapiserver.AssertSmContextUpdateDataConstraints(smContextUpdateDataParam); err != nil {
       //a.individualController.errorHandler(w, r, err, nil)
       openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
       return
   }


   klog.Infof("Data Checks passed")


   // binaryDataN1SmMessageParam, err := ReadFormFileToTempFile(r, "binaryDataN1SmMessage")
   // if err != nil {
   //  //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  return
   // }


   nasMsgParam := r.FormValue("binaryDataN1SmMessage")
   var binaryDataN1SmMessageParam []byte
   json.Unmarshal([]byte(nasMsgParam), &binaryDataN1SmMessageParam)
   klog.Infof("Binary Data: %v", binaryDataN1SmMessageParam)


   // binaryDataN2SmInformationParam, err := ReadFormFileToTempFile(r, "binaryDataN2SmInformation")
   // if err != nil {
   //  //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  return
   // }
   nasMsgParam2 := r.FormValue("binaryDataN2SmInformation")
   var binaryDataN2SmInformationParam []byte
   json.Unmarshal([]byte(nasMsgParam2), &binaryDataN2SmInformationParam)
   klog.Infof("Binary Data: %v", binaryDataN2SmInformationParam)


   // binaryDataN2SmInformationExt1Param, err := ReadFormFileToTempFile(r, "binaryDataN2SmInformationExt1")
   // if err != nil {
   //  //a.individualController.errorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  openapiserver.DefaultErrorHandler(w, r, &openapiserver.ParsingError{Err: err}, nil)
   //  return
   // }


   nasMsgParam3 := r.FormValue("binaryDataN2SmInformationExt1")
   var binaryDataN2SmInformationExt1Param []byte
   json.Unmarshal([]byte(nasMsgParam3), &binaryDataN2SmInformationExt1Param)
   klog.Infof("Binary Data: %v", binaryDataN2SmInformationExt1Param)


   a.apiChannel <- &SessionMessage{
       Ctx:                           ctx, // Pass the tracing context
       MsgType:                       sm.NSMF_UPDATE_SM_CONTEXT_REQUEST,
       SessionMsg:                    smContextUpdateDataParam,
       SmContextRefID:                smContextRefParam,
       BinaryDataN2SmInformation:     binaryDataN2SmInformationParam,
       BinaryDataN1SmMessage:         binaryDataN1SmMessageParam,
       BinaryDataN2SmInformationExt1: binaryDataN2SmInformationExt1Param}


   rec := <-a.apiReceiver
   // klog.Info(rec)


   if rec.RecievedErr != nil {
       span.SetStatus(codes.Error, "UpdateSmContext failed")
       openapiserver.DefaultErrorHandler(
           w, r, &openapiserver.ParsingError{
               Err: rec.RecievedErr,
           }, &rec.RecievedResponse,
       )
       return
   }
   span.SetStatus(codes.Ok, "Successfully processed UpdateSmContext")
   EncodeJSONResponse(rec.RecievedResponse.Body, &rec.RecievedResponse.Code, w)


}


func (a *ApiServerInfo) WatchApiChannel() chan *SessionMessage {
   return a.apiChannel
}


func (a *ApiServerInfo) WatchRecChannel() chan *Receiver {
   return a.apiReceiver
}




This is my pdusmsp.go file:

package pdusmsp


import (
   //"encoding/binary"
   //"net"


   //"sync"


   "context"
   "errors"
   "fmt"
   "strconv"
   "time"


   //  "fmt"
   "k8s.io/klog"
   //"github.com/gin-gonic/gin"
   "github.com/benbjohnson/clock"


   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/api"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/apiclient"
   db "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/database"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpc"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpc/grpcserver"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpc/protos"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/tracing"


   //"w5gc.io/wipro5gcore/pkg/smf/pdusmsp/sm/nodes"


   openapiserver "w5gc.io/wipro5gcore/openapi/openapiserver"


   "go.opentelemetry.io/otel/codes"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/config"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/sm/sessions"
   "w5gc.io/wipro5gcore/utils/cache"


   // "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpc"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/sm"
)


const (
   retransmitInterval = time.Second * 3
   retransmitRetries  = 3
   backoffInterval    = time.Second * 3
   // Period for performing global cleanup tasks.
   housekeepingPeriod = time.Second * 2
)


// PdusmspHandler is an interface implemented for testability
type PdusmspHandler interface {
   //InitiateSessioReportRequest(sessionMsg *pfcpUdp.Message)
   HandleSessionCleanups() error
}


// Bootstrap is a bootstrapping interface for PDU SMS
type PdusmspBootstrap interface {
   //GetConfiguration()
   //GetContext()
   Run(configChannel <-chan config.PdusmspConfig)
}


type Pdusmsp struct {
   config          *config.PdusmspConfig
   sessionManager  sm.SessionManager
   sessionCache    cache.WorkCache
   dbManager       db.DBManager
   grpc            grpc.Grpc
   apiClient       apiclient.ApiClient
   apiServer       api.ApiServer
   sessionWorkers  SessionWorkers
   clock           clock.Clock
   backoffInterval time.Duration
   timerT1         time.Duration
   retriesN1       uint8
   context         *PdusmspContext
}


type PdusmspContext struct {
   startTime   time.Time
   lastRestart time.Time
   restarts    int // If number of restarts in last 10 sec > 3 reset TODO GURU
   //lock                  sync.Mutex
   NodeId string
}


// Initialize Pdusmsp
func NewPdusmsp(cfg *config.PdusmspConfig, time time.Time) (PdusmspBootstrap, bool) {


   pdusmsp := &Pdusmsp{
       config:          cfg,
       clock:           clock.New(),
       backoffInterval: backoffInterval,
       timerT1:         retransmitInterval,
       retriesN1:       retransmitRetries,
       context: &PdusmspContext{
           startTime: time,
       },
   }


   // Intialize the api handler
   //should both apiClient and apiServer be created in newcsc?
   pdusmsp.apiClient = apiclient.NewApiClient(cfg)
   pdusmsp.apiServer = api.NewApiServer(cfg.NodeInfo)


   // Intialize session db
   pdusmsp.dbManager = db.NewDBManager()
   //temperory to be romoved
   dbInfo := pdusmsp.dbManager.(*db.DBInfo)


   // Initialize session manager
   //pdusmsp.sessionManager = sm.NewSessionManager(pdusmsp.config.NodeInfo, pdusmsp.config.n11Nodes, time, pdusmsp.backoffInterval, pdusmsp.timerT1, pdusmsp.retriesN1)


   // Intialize grpc
   pdusmsp.grpc = grpc.NewGrpc(cfg.GrpcServerInfo, cfg.GrpcClientInfo)
   // s:=(pdusmsp.apiClient).(apiclient.ApiClientInfo)
   // var s sm.SessionManager
   pdusmsp.sessionManager = sm.NewSessionManager(dbInfo, &pdusmsp.grpc, pdusmsp.apiClient)
   //  s:= pdusmsp.sessionManager.NewSMContextAPIService()
   //  fmt.Println(s)
   // Intialize session cache
   pdusmsp.sessionCache = cache.NewCache(pdusmsp.clock)


   // Intialize session workers
   pdusmsp.sessionWorkers = NewSessionWorkers(pdusmsp.handleSession, pdusmsp.sessionCache, pdusmsp.backoffInterval)


   // resyncInterval, backOffPeriod TODO GURU


   return pdusmsp, true
}


// Run starts the Pdusmsp
func (p *Pdusmsp) Run(configChannel <-chan config.PdusmspConfig) {
   // start the session manager
   go p.sessionManager.Start()


   // Start the api handler
   p.apiClient.Start()
   go p.apiServer.Start()


   // Start the grpc
   go p.grpc.Start()


   // Start the db Hanlder
   p.dbManager.Start()


   // Start the pdusmsp event handler
   p.pdusmspEvents(configChannel, p)


   // return
}


func (p *Pdusmsp) pdusmspEvents(configChannel <-chan config.PdusmspConfig, handler PdusmspHandler) {
   klog.Infof("Entered into pdusmspEvents")
   syncTicker := time.NewTicker(time.Second)
   defer syncTicker.Stop()
   housekeepingTicker := time.NewTicker(housekeepingPeriod)
   defer housekeepingTicker.Stop()
   sessionChannel := p.apiServer.WatchApiChannel()
   grpcChannel := p.grpc.WatchGrpcChannel()
   p.handlePdusmspEvents(configChannel, sessionChannel, grpcChannel, syncTicker.C, housekeepingTicker.C, handler)
}


// handlePdusmspEvents is the main loop for processing events in pdusmsp
func (p *Pdusmsp) handlePdusmspEvents(configChannel <-chan config.PdusmspConfig, sessionChannel <-chan *api.SessionMessage,
   grpcChannel <-chan *grpcserver.GrpcMessage, syncCh <-chan time.Time, housekeepingCh <-chan time.Time,
   handler PdusmspHandler) bool {
   klog.Info("Entered into handlePdusmspEvents")
   for {
       select {
       // Handle config updates of nodes - TODO GURU
       //case config := <-configChannel:
       //switch config.Entity {
       //case CPNODES:
       // Handle config updates for CP Nodes i.e. SMF nodes
       //switch config.Type
       //case ADDNODE
       //case UPNODES:
       // Handle config updates for UP Nodes i.e. UPFU nodes
       //}
       case grpcMsg := <-grpcChannel:
           grpcMsgType := sm.MessageType(grpcMsg.MsgType)
           switch grpcMsgType {
           case sm.NSMF_N1_N2_TRANSFER:
               klog.Info("handlePdusmspEvents (N1N2Message Transfer)")
               klog.Infof("%+v", *grpcMsg.GrpcMsg)
               // //TODO ask raghu and verify data we are getting
               data := *grpcMsg.GrpcMsg
               // //TODO raghu's datatype to be used here
               trData := data.(*protos.N1N2MessageTransferDataRequest)


               // refId := strconv.Itoa(int(trData.PduSessionId)) + trData.OldGuami.AmfId
               refId := fmt.Sprintf("%v", trData.SmContextID)
               sessionId := sessions.SessionId(refId)
               p.dispatchWork(sessions.SessionId(sessionId),
                   nil,
                   grpcMsg,
                   grpcMsgType,
                   time.Now(),
                   context.Background(),
               )
           }
       case pdusmsMsg := <-sessionChannel:
           switch pdusmsMsg.MsgType {
           case sm.NSMF_CREATE_SM_CONTEXT_REQUEST:
               // PDU Session management service - Create SM Context Request
               klog.Infof("handlePdusmspEvents (CREATE SM CONTEXT REQUEST)")
               //put proper session
               jsonData := pdusmsMsg.SessionMsg
               smData := jsonData.(openapiserver.SmContextCreateData)
               // refContext := strconv.Itoa(int(smData.PduSessionId)) + smData.Guami.AmfId
               refContext := strconv.Itoa(int(smData.PduSessionId)) + smData.Supi
               sessionId := sessions.SessionId(refContext)
               ctx := pdusmsMsg.Request.Context()
               // p.dispatchWork(sessionId, pdusmsMsg, grpcMsg, time.Now())
               p.dispatchWork(
                   sessionId,
                   pdusmsMsg,
                   nil,
                   pdusmsMsg.MsgType,
                   time.Now(),
                   ctx,
               )


           case sm.NSMF_UPDATE_SM_CONTEXT_REQUEST:
               // PDU Session management service - Update SM Context Request
               klog.Infof("handlePdusmspEvents (UPDATE SM CONTEXT  REQUEST)")
               // fmt.Println(reflect.TypeOf(pdusmsMsg.SessionMsg))
               //have to change in future
               // id, err := strconv.Atoi(pdusmsMsg.SmContextRefID)
               // if err != nil {
               //  klog.Error(err.Error())
               // }
               // klog.Info(id)
               sessionId := sessions.SessionId(pdusmsMsg.SmContextRefID)
               // p.dispatchWork(sessionId, pdusmsMsg, grpcMsg, time.Now())
               p.dispatchWork(
                   sessionId,
                   pdusmsMsg,
                   nil,
                   pdusmsMsg.MsgType,
                   time.Now(),
                   pdusmsMsg.Request.Context())


           case sm.NSMF_RELEASE_SM_CONTEXT_REQUEST:
               // PDU Session management service - Release SM Context Request
               klog.Infof("handlePdusmspEvents (RELEASE SM CONTEXT REQUEST)")
               // id, err := strconv.Atoi(pdusmsMsg.SmContextRefID)
               // if err != nil {
               //  klog.Error(err.Error())
               // }
               sessionId := sessions.SessionId(pdusmsMsg.SmContextRefID)
               // p.dispatchWork(sessionId, pdusmsMsg, grpcMsg, time.Now())
               p.dispatchWork(
                   sessionId,
                   pdusmsMsg,
                   nil,
                   pdusmsMsg.MsgType,
                   time.Now(),
                   pdusmsMsg.Request.Context()) // Pass context with tracing info


           case sm.NSMF_RETRIEVE_SM_CONTEXT_REQUEST:
               // PDU Session management service - Retrieve SM Context Request
               klog.Infof("handlePdusmspEvents (RETRIEVE SM CONTEXT REQUEST)")
               // id, err := strconv.Atoi(pdusmsMsg.SmContextRefID)
               // if err != nil {
               //  klog.Error(err.Error())
               // }
               sessionId := sessions.SessionId(pdusmsMsg.SmContextRefID)
               // p.dispatchWork(sessionId, pdusmsMsg, grpcMsg, time.Now())
               p.dispatchWork(
                   sessionId,
                   pdusmsMsg,
                   nil,
                   pdusmsMsg.MsgType,
                   time.Now(),
                   pdusmsMsg.Request.Context())


           }


       // Handle pdusmsp node events, sesssion events/ notificatiosn TODO GURU
       //case event := <-pdusmspEventChannel:
       // Event for a session.
       /*if session, ok := p.sessionManager.GetSession(event.SessionID); ok {
                         klog.V(2).Infof("handlePdusmspEvents (EVENT): %q, event: %#v", format.Sessions(session), event)
                         //handler.HandleSessionEvents()
                 } else {
                         // If the session no longer exists, ignore the event.
                         klog.V(4).Infof("handleUpfcEvents (EVENT): ignore irrelevant event: %#v", e)
                 }
         }


         if event.Type == sessionEvent.SessionDisconnected {


         }*/
       //case config := <-ConfigChan:
       // Check node and send to corresponding channel


       // Handle session sync - TODO GURU
       // To handle asyncs during reboot , configuration error etc
       case <-syncCh:
       // Sync sessions waiting for sync


       /*sessionsToSync := p.getSessionsToSync()
         if len(sessionsToSync) == 0 {
                 break
         }
         klog.V(4).Infof("SyncLoop (SYNC): %d sessions", len(sessionsToSync))
         //handler.HandleSessionSyncs(sessionsToSync)*/


       // Handle house keeping of sessions TODO GURU
       case <-housekeepingCh:
           klog.V(4).Infof("SyncLoop (housekeeping)")
           if err := handler.HandleSessionCleanups(); err != nil {
               klog.Errorf("Failed cleaning session: %v", err)
           }


       }
   }
}


/*func (p *Pdusmsp) getSessionsToSync() {
       allSessions := p.n4Manager.pfcp.sessions
       sessionIds := p.workCache.GetItem()


       var sessionsToSync []*sm.Session
       for _, session := range allSessions {
               if session.sessionId in sessionIds {
                       sessionsToSync = append(sessionsToSync, session)
                       continue
               }
       }
       return sessionsToSync
}*/


func (p *Pdusmsp) HandleSessionCleanups() error {
   deletedSessions := make(map[sessions.SessionId]struct{})
   err := p.sessionWorkers.RemoveSessionWorkers(deletedSessions)
   return err
}


// dispatchWork handles the session in a session worker
func (p *Pdusmsp) dispatchWork(sessionId sessions.SessionId,
   sessionMsg *api.SessionMessage,
   grpcMsg *grpcserver.GrpcMessage,
   msgType sm.MessageType,
   startTime time.Time,
   ctx context.Context) {


   // Ensure the context is not nil
   if ctx == nil {
       klog.Errorf("Context is nil")
       return
   }
   ctx, span := tracing.Tracer.Start(ctx, "dispatchWork")
   defer span.End()


   if msgType == sm.NSMF_N1_N2_TRANSFER {
       p.sessionWorkers.HandleSessionMessages(&SessionMessageInfo{
           SessionId: sessionId,
           StartTime: startTime,
           PdusmsMsg: api.SessionMessage{},
           GrpcMsg:   *grpcMsg,
           MsgType:   msgType,
           OnCompleteFunc: func(err error) {
               // Handle on completion of session update
               if err == nil {
                   klog.Infof("Successfully handled pdusms  for session %s", sessionId)
                   span.SetStatus(codes.Ok, "Successfully handled pdusms")
                   //metrics.SessionWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))
               } else {
                   // Log error and update cause with request rejected
                   klog.Info(err)
                   klog.Errorf("Unable to handle pdusms for session %s", sessionId)
                   span.SetStatus(codes.Error, "Unable to handle pdusms")
               }
           },
       })
       return
   }
   // Run the handle session in an async worker.
   p.sessionWorkers.HandleSessionMessages(&SessionMessageInfo{
       SessionId: sessionId,
       StartTime: startTime,
       PdusmsMsg: *sessionMsg,
       GrpcMsg:   grpcserver.GrpcMessage{},
       MsgType:   msgType,
       OnCompleteFunc: func(err error) {
           // Handle on completion of session update
           if err == nil {
               klog.Infof("Successfully handled pdusms  for session %s", sessionId)
               //metrics.SessionWorkerDuration.WithLabelValues(syncType.String()).Observe(metrics.SinceInSeconds(start))
           } else {
               // Log error and update cause with request rejected
               klog.Info(err)
               klog.Errorf("Unable to handle pdusms for session %s", sessionId)
           }
       },
   })
   // Monitor the session and number of qos flows for the session. TODO GURU
   //metrics.QoSFlowsPerSessionCount.Observe(float64(len(session.flows)))
}


// handleSession handles the pdu session message in a session worker
func (p *Pdusmsp) handleSession(msgInfo SessionMessageInfo) error {
   // Get the required message info
   klog.Info("inside")


   if msgInfo.PdusmsMsg.Request == nil {
       klog.Errorf("Request is nil")
       return errors.New("request is nil")
   }
   _, span := tracing.Tracer.Start(msgInfo.PdusmsMsg.Request.Context(), "handleSession")
   defer func() {
       if err := recover(); err != nil {
           span.SetStatus(codes.Error, "handleSession panicked")
           panic(err)
       }
       span.SetStatus(codes.Ok, "Successfully handled session")
       span.End()
   }()


   msgType := msgInfo.MsgType
   pdusmsMsg := msgInfo.PdusmsMsg
   // grpc->myfunction(process/dbupdate)->callruchi'sfunction
   // Process remote node requests/responses
   switch msgType {
   case sm.NSMF_CREATE_SM_CONTEXT_REQUEST:
       // Process pdusms create request
       //sm.ProcessNsmfCreateSmContextRequest(pdusmsMsg)
       n1SmMessage := pdusmsMsg.BinaryDataN1SmMessage
       jsonData := pdusmsMsg.SessionMsg
       smData := jsonData.(openapiserver.SmContextCreateData)
       resp, err := p.sessionManager.ProcessNsmfCreateSmContextRequest(smData, n1SmMessage)
       chanRec := p.apiServer.WatchRecChannel()
       chanRec <- &api.Receiver{RecievedResponse: resp, RecievedErr: err}
       return err
   case sm.NSMF_UPDATE_SM_CONTEXT_REQUEST:
       // Process pdusms update request
       n1SmMessage := pdusmsMsg.BinaryDataN1SmMessage
       n2SmMessage := pdusmsMsg.BinaryDataN2SmInformation
       n2SmExt1Message := pdusmsMsg.BinaryDataN2SmInformationExt1
       smcontextref := pdusmsMsg.SmContextRefID
       jsonData := pdusmsMsg.SessionMsg
       smData := jsonData.(openapiserver.SmContextUpdateData)
       resp, err := p.sessionManager.ProcessNsmfUpdateSmContextRequest(smcontextref, smData, n1SmMessage, n2SmMessage, n2SmExt1Message)
       //sm.ProcessNsmfUpdateSmContextRequest(pdusmsMsg)
       chanRec := p.apiServer.WatchRecChannel()
       chanRec <- &api.Receiver{RecievedResponse: resp, RecievedErr: err}
       return err
   case sm.NSMF_RELEASE_SM_CONTEXT_REQUEST:
       // Process pdusms release request
       n2SmMessage := pdusmsMsg.BinaryDataN2SmInformation
       smcontextref := pdusmsMsg.SmContextRefID
       jsonData := pdusmsMsg.SessionMsg
       smData := jsonData.(openapiserver.SmContextReleaseData)
       resp, err := p.sessionManager.ProcessNsmfReleaseSmContextRequest(smcontextref, smData, n2SmMessage)
       //sm.ProcessNsmfReleaseSmContextRequest(pdusmsMsg)
       chanRec := p.apiServer.WatchRecChannel()
       chanRec <- &api.Receiver{RecievedResponse: resp, RecievedErr: err}
       return err
   case sm.NSMF_RETRIEVE_SM_CONTEXT_REQUEST:
       // Process pdusms retrieve request
       smcontextref := pdusmsMsg.SmContextRefID
       jsonData := pdusmsMsg.SessionMsg
       smData := jsonData.(openapiserver.SmContextRetrieveData)
       resp, err := p.sessionManager.ProcessNsmfRetrieveSmContextRequest(smcontextref, smData)
       //sm.ProcessNsmfRetrieveSmContextRequest(pdusmsMsg)
       chanRec := p.apiServer.WatchRecChannel()
       chanRec <- &api.Receiver{RecievedResponse: resp, RecievedErr: err}
       return err
   case sm.NSMF_N1_N2_TRANSFER:
       recGrpcMsg := (*msgInfo.GrpcMsg.GrpcMsg).(*protos.N1N2MessageTransferDataRequest)
       //hardcoded for now
       // ip := "pdusmsp-service.pdusmsp.svc.cluster.local" //change to amf IP based on certain conditions // to ask Guru
       ip := "csp-service.csp.svc.cluster.local"
       p.sessionManager.ProcessN1N2Message(recGrpcMsg, ip)
   }
   return nil
}




This is my sm.go file:

package sm


import (
   "context"
   "encoding/json"
   "errors"
   "fmt"
   "net/http"


   // "os"
   "regexp"
   "strconv"
   "time"


   "github.com/go-redis/redis/v8"
   "github.com/gogo/protobuf/proto"
   "github.com/prometheus/client_golang/prometheus"
   "github.com/prometheus/client_golang/prometheus/promauto"
   "github.com/prometheus/client_golang/prometheus/promhttp"
   "go.opentelemetry.io/otel/attribute"
   "go.opentelemetry.io/otel/codes"
   "google.golang.org/protobuf/types/known/anypb"
   "k8s.io/klog"
   "w5gc.io/wipro5gcore/openapi/openapi_commn_client"
   openapiserver "w5gc.io/wipro5gcore/openapi/openapiserver"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/apiclient"
   db "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/database"
   redisClient "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/database/redis"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpc"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpc/protos"
   grpcnas "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpcNAS"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpcNAS/grpcSmfNas/pb"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/grpcNAS/nas"
   ipgenerator "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/ipGenerator"
   "w5gc.io/wipro5gcore/pkg/smf/pdusmsp/tracing"
)


var (
   createProcess = promauto.NewCounter(prometheus.CounterOpts{
       Name: "sm_create_operations_total",
       Help: "The total number of SM create operations",
   })


   updateProcess = promauto.NewCounter(prometheus.CounterOpts{
       Name: "sm_update_operations_total",
       Help: "The total number of SM update operations",
   })


   retrieveProcess = promauto.NewCounter(prometheus.CounterOpts{
       Name: "sm_retrieve_operations_total",
       Help: "The total number of SM retrieve operations",
   })


   releaseProcess = promauto.NewCounter(prometheus.CounterOpts{
       Name: "sm_release_operations_total",
       Help: "The total number of SM release operations",
   })
   UsersPerSession = promauto.NewGaugeVec(
       prometheus.GaugeOpts{
           Name: "users_per_session_id",
           Help: "Tracks the number of users per session ID",
       },
       []string{"session_id", "user_id", "pei"},
   )
   createSessionSuccess = promauto.NewCounter(prometheus.CounterOpts{
       Name: "sm_create_session_success_total",
       Help: "The total number of successful session creations",
   })


   createSessionAttempts = promauto.NewCounter(prometheus.CounterOpts{
       Name: "sm_create_session_attempts_total",
       Help: "The total number of session creation attempts",
   })
)


type SessionManager interface {
   Start()
   ProcessNsmfReleaseSmContextRequest(smContextRef string, smContextReleaseData openapiserver.SmContextReleaseData, binaryN2SMInformation []byte) (openapiserver.ImplResponse, error)
   ProcessNsmfRetrieveSmContextRequest(smContextRef string, smContextRetrieveData openapiserver.SmContextRetrieveData) (openapiserver.ImplResponse, error)
   ProcessNsmfUpdateSmContextRequest(smContextRef string, smContextUpdateData openapiserver.SmContextUpdateData, binaryDataN1SmMessage []byte, binaryN2SMInformation []byte, binaryDataN2SmInformationExt1 []byte) (openapiserver.ImplResponse, error)
   ProcessNsmfCreateSmContextRequest(jsonData openapiserver.SmContextCreateData, binaryDataN1SmMessage []byte) (openapiserver.ImplResponse, error)
   ProcessN1N2Message(grpcMsg *protos.N1N2MessageTransferDataRequest, ip string) error
}


type SMContextMessage interface{}


type MessageType uint8


const (
   NSMF_CREATE_SM_CONTEXT_REQUEST    MessageType = 1
   NSMF_CREATE_SM_CONTEXT_RESPONSE   MessageType = 2
   NSMF_UPDATE_SM_CONTEXT_REQUEST    MessageType = 3
   NSMF_UPDATE_SM_CONTEXT_RESPONSE   MessageType = 4
   NSMF_RELEASE_SM_CONTEXT_REQUEST   MessageType = 5
   NSMF_RELEASE_SM_CONTEXT_RESPONSE  MessageType = 6
   NSMF_RETRIEVE_SM_CONTEXT_REQUEST  MessageType = 7
   NSMF_RETRIEVE_SM_CONTEXT_RESPONSE MessageType = 8
   NSMF_N1_N2_TRANSFER               MessageType = 11
)


// try to have a single client
// make context as a part of sminfo
// temp struct
type SmInfo struct {
   ctx context.Context
   // sessionDb *redis.Client // Redis client for database 0
   // userDb    *redis.Client // Redis client for database 1
   // dbClient *redis.Client
   DbClient  *db.DBInfo
   grpc      *grpc.Grpc
   apiClient apiclient.ApiClient
}


func NewSessionManager(info *db.DBInfo, grpc *grpc.Grpc, apiclient apiclient.ApiClient) *SmInfo {
   // ctx := context.Background()
   // sessionClient, err := redisClient.NewRedisClient(ctx, 0)
   // if err != nil {
   //  // Handle error
   //  klog.Error("unable to connect to session Database")
   //  klog.Info(err)
   // }


   // userClient, err := redisClient.NewRedisClient(ctx, 1)
   // if err != nil {
   //  // Handle error
   //  klog.Error("unable to connect to user Database")
   //  klog.Info(err)
   // }


   // return &SmInfo{
   //  // smcontextTable:   make(map[string]SessionContext),
   //  // userContextTable: make(map[string]UserContext),
   //  ctx:       ctx,
   //  sessionDb: sessionClient,
   //  userDb:    userClient,
   // }
   // client, err := redisClient.NewRedisClient(ctx, redisClient.SessionDb)
   // if err != nil {
   //  klog.Errorf("unable to connect to session Database,%s", err.Error())
   //  return &SmInfo{
   //      ctx:      ctx,
   //      dbClient: nil,
   //  }
   // }
   return &SmInfo{
       ctx:       context.Background(),
       DbClient:  info,
       grpc:      grpc,
       apiClient: apiclient,
   }
}


func (s *SmInfo) Start() {
   klog.Info("starting tracer")
   tracing.InitTracer()
   klog.Info("starting session manager")
   http.Handle("/metrics", promhttp.Handler())
   http.ListenAndServe(":2112", nil)
}


//  func (s *SessionManagerInfo) NewSMContextAPIService() *SMContextAPIService {
//      return s.smContextAPI
//
// Helper function to convert SessionContext to JSON
// }
func SessionContextToJSON(sessionContext SessionContext) string {
   data, err := json.Marshal(sessionContext)
   if err != nil {
       klog.Errorf("Error converting SessionContext to JSON: %v", err)
       return ""
   }
   return string(data)
}


// Helper function to convert UserContext to JSON
func UserContextToJSON(userContext UserContext) string {
   data, err := json.Marshal(userContext)
   if err != nil {
       klog.Errorf("Error converting UserContext to JSON: %v", err)
       return ""
   }
   return string(data)
}


// requestType - emergeny | not taken TODO
func validateData(jsonData openapiserver.SmContextCreateData) error {


   //TODO check condition - if amf is not the sender - for later
   supiValid, _ := regexp.MatchString("^(imsi-[0-9]{5,15}|nai-.+|.+)$", jsonData.Supi)
   if !supiValid {
       return errors.New("invalid supi")
   }
   // gpsiValid, _ := regexp.MatchString("^(msisdn-[0-9]{5,15}|extid-.+@.+|.+)$", jsonData.Gpsi)
   // if !gpsiValid {
   //  return errors.New("invalid gpsi")
   // }
   peiValid, _ := regexp.MatchString("^(imei-[0-9]{15}|imeisv-[0-9]{16}|.+)$", jsonData.Pei)
   if !peiValid {
       return errors.New("invalid pei")
   }
   amfidValid, _ := regexp.MatchString("^[A-Fa-f0-9]{6}$", jsonData.Guami.AmfId)
   gMccValid, _ := regexp.MatchString("^[0-9]{3}$", jsonData.Guami.PlmnId.Mcc)
   gMncValid, _ := regexp.MatchString("^[0-9]{2,3}$", jsonData.Guami.PlmnId.Mnc)
   guamiValid := amfidValid && gMccValid && gMncValid
   if !guamiValid {
       return errors.New("invalid guami")
   }
   snMccValid, _ := regexp.MatchString("^[0-9]{3}$", jsonData.ServingNetwork.Mcc)
   snMncValid, _ := regexp.MatchString("^[0-9]{2,3}$", jsonData.ServingNetwork.Mnc)
   servingNetworkValid := snMccValid && snMncValid
   if !servingNetworkValid {
       return errors.New("invalid servingNetwork")
   }
   return nil
}


// func (s *SmInfo) changeDatabase(redisDb redisClient.Database) {
//  s.dbClient = redisClient.ChangeRedisDatabase(s.dbClient, redisDb)
// }


// func upfSessionCreate(data openapiserver.RefToBinaryData) (openapiserver.ImplResponse, error) {
//  return openapiserver.Response(200, nil), nil
// }


// ProcessNsmfCreateSmContextRequest - Create SM Context
func (s *SmInfo) ProcessNsmfCreateSmContextRequest(
   // ctx context.Context,
   jsonData openapiserver.SmContextCreateData, binaryDataN1SmMessage []byte) (openapiserver.ImplResponse, error) {
   // TODO - update ProcessNsmfCreateSmContextRequest with the required logic for this service method.
   // Add api_sm_contexts_collection_service.go to the .openapiserver-generator-ignore to avoid overwriting this service implementation when updating open api gen>
   klog.Info("create function initiated")
   createSessionAttempts.Inc()


   ctx := jsonData.HTTPRequest.Context()


   // Start a child span using this context
   ctx, span := tracing.Tracer.Start(ctx, "ProcessNsmfCreateSmContextRequest")
   defer span.End()


   // Log session creation attributes
   span.SetAttributes(
       // attribute.String("session.id", jsonData.Supi),
       attribute.String("operation", "create"),
   )


   if jsonData.PduSessionId == 0 {
       return openapiserver.Response(403, openapiserver.SmContextCreateError{Error: openapiserver.ProblemDetails{Title: "invalid request data",
           Type: "validityErr", Status: 403, Detail: "invalid PduSessionId "}, N1SmMsg: jsonData.N1SmMsg}), errors.New("invalid PduSessionId")
   }


   // Start a child span for validating data
   _, validationSpan := tracing.Tracer.Start(ctx, "validateData")
   defer validationSpan.End()


   validityErr := validateData(jsonData)
   klog.Info(validityErr)


   if validityErr != nil {
       return openapiserver.Response(403, openapiserver.SmContextCreateError{Error: openapiserver.ProblemDetails{Title: "invalid request data",
           Type: "validityErr", Status: 403, Detail: validityErr.Error()}, N1SmMsg: jsonData.N1SmMsg}), validityErr
   }


   validationSpan.SetStatus(codes.Ok, "Validation successful")
   // get connection attributes related to the session
   /*  user, found := s.userContextTable[jsonData.Supi]
       if found {
           //assumingmax allowed devices is 15
           if user.NoSession == 15 {
               // recheck in specs
               return openapiserver.Response(401, openapiserver.SmContextCreateError{Error: openapiserver.ProblemDetails{Title: "Connection limit exceeded",
                   Type: "ConnectionLimitErr", Status: 401, Detail: "device not allowed to have more than 15 connections"},
                   N1SmMsg: jsonData.N1SmMsg}), errors.New("device not allowed to have more than 15 connections")
           }
       }
   */
   //contextRefId is PduSessionId concatenated with SUPI
   klog.Info("Creating ContextRefId")
   // contextRefId := strconv.Itoa(int(jsonData.PduSessionId)) + jsonData.Guami.AmfId
   contextRefId := strconv.Itoa(int(jsonData.PduSessionId)) + jsonData.Supi
   var sessionData SessionContext


   _, dbSpan := tracing.Tracer.Start(ctx, "databaseOperations")
   defer dbSpan.End()


   // sData, exists := s.sessionDb.Get(s.ctx, contextRefId).Result()
   // s.changeDatabase(redisClient.SessionDb)
   // sData, exists := s.dbClient.Get(s.ctx, contextRefId).Result()
   // sData, exists := redisClient.Read(contextRefId, redisClient.SessionDb, s.dbClient)
   sData, exists := s.DbClient.Redis.Read(contextRefId, redisClient.SessionDb)
   klog.Info("sessionContext: ", sData)
   json.Unmarshal([]byte(sData), &sessionData)


   //TODO Should request be buffered to handle later
   if exists == nil {
       if sessionData.State == openapiserver.ACTIVATING {
           // klog.Info("inside")
           return openapiserver.Response(403, openapiserver.SmContextCreateError{
               Error: openapiserver.ProblemDetails{
                   Title:  "Already in Progress",
                   Type:   "ALreadyInProgressErr",
                   Status: 403,
                   Detail: "request already in progress",
               },
               N1SmMsg: jsonData.N1SmMsg,
           }), errors.New("request already in progress")
       }
   }


   dbSpan.SetStatus(codes.Ok, "Session created in database")


   var user UserContext


   //TODO only use one call to both function (put it in redisClient)
   // dbData, err := s.userDb.Get(s.ctx, jsonData.Supi).Result()
   // s.changeDatabase(redisClient.UserDb)
   // userData, err := s.dbClient.Get(s.ctx, jsonData.Supi).Result()
   userData, err := s.DbClient.Redis.Read(jsonData.Supi, redisClient.UserDb)
   // klog.Infof("UserContext,err: %+v,%+v", userData, )


   if err != nil {
       if errors.Is(err, redis.Nil) || err.Error() == "failed to get data in Redis: redis: nil" {
           user = UserContext{NoSession: 0}
       } else {
           klog.Info("iwashere")
           return openapiserver.Response(500, openapiserver.SmContextCreateError{
               Error: openapiserver.ProblemDetails{
                   Title:  "Unable to access redis data",
                   Type:   "RedisDatabaseError",
                   Status: 500,
                   Detail: err.Error(),
               },
               N1SmMsg: jsonData.N1SmMsg,
           }), err
       }
   } else {
       json.Unmarshal([]byte(userData), &user)
   }
   //assumingmax allowed devices is 15
   if user.NoSession == 15 {
       return openapiserver.Response(401, openapiserver.SmContextCreateError{
           Error: openapiserver.ProblemDetails{
               Title:  "Connection limit exceeded",
               Type:   "ConnectionLimitErr",
               Status: 401,
               Detail: "device not allowed to have more than 15 connections",
           },
           N1SmMsg: jsonData.N1SmMsg,
       }), errors.New("device not allowed to have more than 15 connections")
   }


   ueContextId := jsonData.Supi
   //grpc code
   createData := protos.SmContextCreateDataRequest{
       SmContextID: contextRefId,
       N4ReqType:   "N4 Establishment Request",
       UeContextID: ueContextId,
       // Supi:         jsonData.Supi,
       // PduSessionId: jsonData.PduSessionId,
       // Guami: &protos.Guami{
       //  PlmnId: &protos.PlmnId{
       //      Mcc: jsonData.Guami.PlmnId.Mcc,
       //      Mnc: jsonData.Guami.PlmnId.Mnc,
       //  },
       //  AmfId: jsonData.Guami.AmfId,
       // },
       // ServingNfId: jsonData.ServingNfId,
       // UnauthenticatedSupi: jsonData.UnauthenticatedSupi,
       // Pei:                 jsonData.Pei,
       // Gpsi:                jsonData.Gpsi,
       // Dnn:                 jsonData.Dnn,
       // ServingNetwork: &protos.PlmnId{
       //  Mcc: jsonData.ServingNetwork.Mcc,
       //  Mnc: jsonData.ServingNetwork.Mnc,
       // },
       // RequestType: string(jsonData.RequestType),
       // N1SmMessage: &protos.N1SmMessage{
       //  PduSessionEstablishmentRequest: &protos.PduSessionEstablishmentRequest{
       //      PduSessionId: jsonData.PduSessionId,
       //  },
       // },
       // AnType:             string(jsonData.AnType),
       // RatType:            string(jsonData.RatType),
       // SmContextStatusUri: jsonData.SmContextStatusUri,
   }
   (*s.grpc).SendSmContextCreateData(&createData)


   //Decode Nas Message
   // var nasMsg interface{}


   klog.Info(binaryDataN1SmMessage)


   anyMessage, err := anypb.New(&pb.ByteDataWrapper{ByteArray: binaryDataN1SmMessage})
   if err != nil {
       klog.Fatalf("Failed to create Any message: %v", err)
   }


   reqType := "" // Empty string for the request type


   ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
   defer cancel()


   //client, ctx := grpcnas.CreateGRPCNasClient()
   client := grpcnas.CreateGRPCNasClient()


   // Send the request
   resp, err := client.HandleEstablishment(ctx, &pb.EstRequest{
       NasMessage: anyMessage,
       TypeReq:    reqType,
   })
   if err != nil {
       klog.Fatalf("Error sending SMData: %v", err)
   }


   klog.Infof("Decoded binaryDataN1SmMessage: %v", resp.NasResponse)


   nasResp := &pb.PDUSEstReqModel{}


   err = resp.NasResponse.UnmarshalTo(nasResp)
   if err != nil {
       klog.Fatalf("Error unmarshalling NAS decoded Message: %v", err)
   }


   sessionData = SessionContext{
       Supi:                               jsonData.Supi,
       Pei:                                jsonData.Pei,
       ServingNfId:                        jsonData.ServingNfId,
       State:                              openapiserver.ACTIVATING,
       SubState:                           ACTIVATING_CREATE_IN_PROGRESS,
       UnauthenticatedSupi:                jsonData.UnauthenticatedSupi,
       Gpsi:                               jsonData.Gpsi,
       FDnn:                               jsonData.Dnn,
       Guami:                              jsonData.Guami,
       ServiceName:                        jsonData.ServiceName,
       ServingNetwork:                     jsonData.ServingNetwork,
       AnType:                             jsonData.AnType,
       RatType:                            jsonData.RatType,
       SmContextStatusUri:                 jsonData.SmContextStatusUri,
       PduSessionId:                       jsonData.PduSessionId,
       ContextRefId:                       contextRefId,
       UeContextId:                        ueContextId,
       NASepd:                             nasResp.Epd,
       NASpduSessionId:                    int(*nasResp.PdusessionID),
       NASpti:                             int(*nasResp.Pti),
       NASmsgType:                         nasResp.MsgType,
       NASmaxIntegrityProtectedDataRateUL: nasResp.DatarateUL,
       NASmaxIntegrityProtectedDataRateDL: nasResp.DatarateDL,
   }


   // Store data in Redis database 0
   //        err := s.sessionDb.Set(ctx,, "Keshav", 0).Err()
   // contextRefId := strconv.Itoa(int(jsonData.PduSessionId)) + jsonData.Guami.AmfId
   // s.changeDatabase(redisClient.SessionDb)
   // err = s.dbClient.Set(s.ctx, contextRefId, SessionContextToJSON(sessionData), 0).Err()


   // err = s.sessionDb.Set(s.ctx, contextRefId, SessionContextToJSON(sessionData), 0).Err()


   _, err = s.DbClient.Redis.Create(
       contextRefId,
       SessionContextToJSON(sessionData),
       redisClient.SessionDb,
   )


   if err != nil {
       klog.Errorf("Error storing data in Redis database 0: %v", err)
       return openapiserver.Response(http.StatusInternalServerError, nil), errors.New("internal server error")
   }


   //send to channel to upf (ask raghu)


   user = UserContext{user.NoSession + 1}
   // s.changeDatabase(redisClient.UserDb)
   // err = s.dbClient.Set(s.ctx, jsonData.Supi, UserContextToJSON(user), 0).Err()
   // err = s.userDb.Set(s.ctx, jsonData.Supi, UserContextToJSON(user), 0).Err()


   _, err = s.DbClient.Redis.Create(
       jsonData.Supi,
       UserContextToJSON(user),
       redisClient.UserDb,
   )


   if err != nil {
       return openapiserver.Response(500, openapiserver.SmContextCreateError{
           Error: openapiserver.ProblemDetails{
               Title:  "Unable to Store Session data",
               Type:   "RedisDatabaseError",
               Status: 500,
               Detail: err.Error(),
           },
           N1SmMsg: jsonData.N1SmMsg,
       }), err
   }


   createProcess.Inc()
   span.SetStatus(codes.Ok, "Session created successfully")


   pduSessionIdStr := fmt.Sprintf("%d", sessionData.PduSessionId)
   UsersPerSession.WithLabelValues(pduSessionIdStr, sessionData.Supi, sessionData.Pei).Inc()


   createSessionSuccess.Inc()


   // Increment the UsersPerSession metric
   // UsersPerSession.WithLabelValues(pduSessionIdStr, sessionData.Supi+"_"+sessionData.Pei).Inc()
   //On success, "201 Created" shall be returned, the payload body of the POST response shall contain the representation describing the status of the request and the "Location" header shall be present and shall contain the URI of the created resource. The authority and/or deployment-specific string of the apiRoot of the created resource URI may differ from the authority and/or deployment-specific string of the apiRoot of the request URI received in the POST request.
   return openapiserver.Response(201, openapiserver.SmContextCreatedData{
       UpCnxState:   sessionData.State,
       PduSessionId: sessionData.PduSessionId,
   }), nil


}
func validateDataUpdate(jsonData openapiserver.SmContextUpdateData) error {


   peiValid, _ := regexp.MatchString("^(imei-[0-9]{15}|imeisv-[0-9]{16}|.+)$", jsonData.Pei)
   if !peiValid {
       return errors.New("invalid pei")
   }
   amfidValid, _ := regexp.MatchString("^[A-Fa-f0-9]{6}$", jsonData.Guami.AmfId)
   gMccValid, _ := regexp.MatchString("^[0-9]{3}$", jsonData.Guami.PlmnId.Mcc)
   gMncValid, _ := regexp.MatchString("^[0-9]{2,3}$", jsonData.Guami.PlmnId.Mnc)
   guamiValid := amfidValid && gMccValid && gMncValid
   if !guamiValid {
       return errors.New("invalid guami")
   }
   snMccValid, _ := regexp.MatchString("^[0-9]{3}$", jsonData.ServingNetwork.Mcc)
   snMncValid, _ := regexp.MatchString("^[0-9]{2,3}$", jsonData.ServingNetwork.Mnc)
   servingNetworkValid := snMccValid && snMncValid
   if !servingNetworkValid {
       return errors.New("invalid servingNetwork")
   }
   return nil


}


// UpdateSmContext - Update SM Context
func (s *SmInfo) ProcessNsmfUpdateSmContextRequest(smContextRef string, smContextUpdateData openapiserver.SmContextUpdateData, binaryDataN1SmMessage []byte, binaryDataN2SmInformation []byte, binaryDataN2SmInformationExt1 []byte) (openapiserver.ImplResponse, error) {


   n1MessageResponse := make([]byte, 0)


   ctx, span := tracing.Tracer.Start(context.Background(), "ProcessNsmfUpdateSmContextRequest")
   defer span.End()


   span.SetAttributes(
       attribute.String("smContextRef", smContextRef),
       attribute.String("operation", "update"),
   )


   klog.Info("Update is working")
   // Validate input parameters
   // Returns a `400 Bad Request` response if the smContextRef is empty.
   if smContextRef == "" {
       return openapiserver.Response(http.StatusBadRequest, openapiserver.SmContextUpdateError{
           Error: openapiserver.ProblemDetails{
               Title:  "Context Reference is empty",
               Type:   "ValidityErr",
               Detail: "smContextRef must not be empty",
               Status: 400,
               Cause:  "MANDATORY_QUERY_PARMS_MISSING",
           },
           N1SmMsg:      smContextUpdateData.N1SmMsg,
           N2SmInfo:     smContextUpdateData.N2SmInfo,
           N2SmInfoType: smContextUpdateData.N2SmInfoType,
       }), errors.New("smContextRef must not be empty")
   }


   // Validate the smContextUpdateData
   err := validateDataUpdate(smContextUpdateData)
   if err != nil {
       // Handle error from data validation
       return openapiserver.Response(http.StatusBadRequest, openapiserver.SmContextUpdateError{
           Error: openapiserver.ProblemDetails{
               Title:  "Invalid data sent",
               Type:   "ValidityErr",
               Detail: err.Error(),
               Status: 400,
               Cause:  "",
           },
           N1SmMsg:      smContextUpdateData.N1SmMsg,
           N2SmInfo:     smContextUpdateData.N2SmInfo,
           N2SmInfoType: smContextUpdateData.N2SmInfoType,
       }), err
   }


   // Check if the SM context exists
   var sessionData SessionContext


   // dbData, err := s.sessionDb.Get(s.ctx, smContextRef).Result()
   // s.changeDatabase(redisClient.SessionDb)
   // dbData, err := s.dbClient.Get(s.ctx, smContextRef).Result()


   sData, err := s.DbClient.Redis.Read(smContextRef, redisClient.SessionDb)


   // klog.Info(sData, err)
   json.Unmarshal([]byte(sData), &sessionData)
   if err != nil {
       if errors.Is(err, redis.Nil) || err.Error() == "failed to get data in Redis: redis: nil" {
           return openapiserver.Response(http.StatusNotFound, openapiserver.SmContextUpdateError{
               Error: openapiserver.ProblemDetails{
                   Title:  "Session Context Not found",
                   Type:   "NotFoundErr",
                   Detail: "Session context corresponding to smContextRef not found",
                   Status: 404,
                   Cause:  "CONTEXT_NOT_FOUND",
               },
               N1SmMsg:      smContextUpdateData.N1SmMsg,
               N2SmInfo:     smContextUpdateData.N2SmInfo,
               N2SmInfoType: smContextUpdateData.N2SmInfoType,
           }), errors.New("session context corresponding to smContextRef not found")
       } else {
           return openapiserver.Response(http.StatusNotFound, openapiserver.SmContextUpdateError{
               Error: openapiserver.ProblemDetails{
                   Title:  "Redis Database Error",
                   Type:   "InternalSernerError",
                   Detail: err.Error(),
                   Status: 404,
                   Cause:  "Database_Error",
               },
               N1SmMsg:      smContextUpdateData.N1SmMsg,
               N2SmInfo:     smContextUpdateData.N2SmInfo,
               N2SmInfoType: smContextUpdateData.N2SmInfoType,
           }), err
       }
   }


   /*
       if sessionData.State == openapiserver.ACTIVATING {
           return openapiserver.Response(403, openapiserver.SmContextUpdateError{
               Error: openapiserver.ProblemDetails{
                   Title:  "Already in Progress",
                   Type:   "AlreadyInProgress",
                   Detail: "Session already in Progress",
                   Status: 403,
               },
               N1SmMsg:      smContextUpdateData.N1SmMsg,
               N2SmInfo:     smContextUpdateData.N2SmInfo,
               N2SmInfoType: smContextUpdateData.N2SmInfoType,
               UpCnxState:   sessionData.State,
           }), errors.New("request already in progress")
       }
   */ // Update the SM context
   // Updates the SM context in the
   //TODO check if field exists then only change


   //fill pduSessionResourceSetup... after decode
   // updateData := protos.SmContextUpdateDataRequest{
   //  ServingNfId:  sessionData.ServingNfId,
   //  Pei:          sessionData.Pei,
   //  PduSessionId: sessionData.PduSessionId,
   //  Guami: &protos.Guami{
   //      PlmnId: &protos.PlmnId{
   //          Mcc: sessionData.Guami.PlmnId.Mcc,
   //          Mnc: sessionData.Guami.PlmnId.Mnc,
   //      },
   //      AmfId: sessionData.Guami.AmfId,
   //  },
   //  SmContextStatusUri: sessionData.SmContextStatusUri,
   //  ServingNetwork: &protos.PlmnId{
   //      Mcc: sessionData.ServingNetwork.Mcc,
   //      Mnc: sessionData.ServingNetwork.Mnc,
   //  },
   // }
   // (*s.grpc).SendSmContextUpdateData(&updateData)


   //Initiate variables to store in redis
   var epd, msgType, cause string
   var pduSessionID, pti int


   //If N1 SM Container is present it will be decoded
   if binaryDataN1SmMessage != nil {
       //Create any message with byte array
       anyN1Message, err := anypb.New(&pb.ByteDataWrapper{ByteArray: binaryDataN1SmMessage})
       if err != nil {
           klog.Fatalf("Failed to create Any message: %v", err)
       }


       reqType := "Decode" //Decode for the request type


       ctxN1, cancel := context.WithTimeout(context.Background(), 5*time.Second)
       defer cancel()


       // clientN1, ctxN1 := grpcnas.CreateGRPCNasClient()
       clientN1 := grpcnas.CreateGRPCNasClient()


       // Send the request
       respN1, err := clientN1.HandleUpdateRelease(ctxN1, &pb.UpRelRequest{
           NasRelMsg: anyN1Message,
           ReqType:   reqType,
       })
       if err != nil {
           klog.Fatalf("Error sending Update Release Data: %v", err)
       }


       klog.Infof("Decoded binaryDataN1SmMessage: %v", respN1.NasResponse.Value)


       // nasResp := &pb.PDUSModReqModel{}


       // err = respN1.NasResponse.UnmarshalTo(nasResp)
       // if err != nil {
       //  klog.Fatalf("Error unmarshalling NAS decoded Message: %v", err)
       // }
       epd, pduSessionID, pti, msgType, cause, err = extractData(respN1.NasResponse, respN1.ReqType)
       if err != nil {
           klog.Fatalf("Error unmarshalling NAS decoded Message: %v", err)
       }
   }


   if msgType == "PDU_SESSION_RELEASE_REQUEST" {
       _, releaseSpan := tracing.Tracer.Start(ctx, "ReleaseProcessing")
       defer releaseSpan.End()


       releaseSpan.SetAttributes(
           attribute.String("release.reason", cause),
           attribute.String("session.id", smContextRef),
       )
       klog.Info("Sending GRPC request to upfgw")
       updateData := protos.SmContextUpdateDataRequest{SmContextID: smContextRef, N4ReqType: "N4 Release Request"}
       (*s.grpc).SendSmContextUpdateData(&updateData)
       // Error handling with span status
       if err != nil {
           releaseSpan.RecordError(err)
           releaseSpan.SetStatus(codes.Error, "Release failed")
       } else {
           releaseSpan.SetStatus(codes.Ok, "Release processed")
       }
   }


   // anyN2Message, err := anypb.New(&pb.ByteDataWrapper{ByteArray: binaryDataN2SmInformation})
   // if err != nil {
   //  klog.Fatalf("Failed to create Any message: %v", err)
   // }
   // clientN2, ctxN2 := grpcnas.CreateGRPCNasClient()


   // // Send the request
   // respN2, err := clientN2.SendSMData(ctxN2, &pb.SMDataRequest{
   //  NasMessage: anyN2Message,
   //  TypeReq:    reqType,
   // })
   // if err != nil {
   //  klog.Fatalf("Error sending SMData: %v", err)
   // }
   // klog.Infof("Decoded binaryDataN2SmInformation: %v", respN2.NasResponse.Value)


   // anyN2Ext1Message, err := anypb.New(&pb.ByteDataWrapper{ByteArray: binaryDataN2SmInformationExt1})
   // if err != nil {
   //  klog.Fatalf("Failed to create Any message: %v", err)
   // }
   // clientN2Ext1, ctxN2Ext1 := grpcnas.CreateGRPCNasClient()


   // // Send the request
   // respN2Ext1, err := clientN2Ext1.SendSMData(ctxN2Ext1, &pb.SMDataRequest{
   //  NasMessage: anyN2Ext1Message,
   //  TypeReq:    reqType,
   // })
   // if err != nil {
   //  klog.Fatalf("Error sending SMData: %v", err)
   // }
   // klog.Infof("Decoded binaryDataN2SmInformation: %v", respN2Ext1.NasResponse.Value)


   session := SessionContext{
       Pei:                 smContextUpdateData.Pei,
       ServingNfId:         smContextUpdateData.ServingNfId,
       ServingNetwork:      smContextUpdateData.ServingNetwork,
       Supi:                sessionData.Supi,
       Gpsi:                sessionData.Gpsi,
       ServiceName:         sessionData.ServiceName,
       RatType:             smContextUpdateData.RatType,
       AnType:              smContextUpdateData.AnType,
       UnauthenticatedSupi: sessionData.UnauthenticatedSupi,
       // PduSessionId: sessionData.PduSessionId,
       FDnn:               sessionData.FDnn,
       Guami:              smContextUpdateData.Guami,
       SmContextStatusUri: smContextUpdateData.SmContextStatusUri,
       NASepd:             epd,
       NASpduSessionId:    pduSessionID,
       NASpti:             pti,
       NASmsgType:         msgType,
       NASSmCause:         cause,
   }


   // Update data in Redis database 0


   // err = s.sessionDb.Set(s.ctx, smContextRef, SessionContextToJSON(session), 0).Err()
   // s.changeDatabase(redisClient.SessionDb)
   // err = s.dbClient.Set(s.ctx, smContextRef, SessionContextToJSON(session), 0).Err()


   _, err = s.DbClient.Redis.Create(
       smContextRef,
       SessionContextToJSON(session),
       redisClient.SessionDb,
   )


   if err != nil {
       klog.Errorf("Error updating data in Redis database 0 for smContextRef %s: %v", smContextRef, err)
       //TODO proper response as per openapi
       return openapiserver.Response(http.StatusInternalServerError, nil), errors.New("internal server error")
   }
   updateProcess.Inc()


   if sessionData.NASmsgType == "PDU_SESSION_RELEASE_REQUEST" {
       //Checks to be added to reject the release as well
       releaseCommand, err := buildReleaseCommand(s, smContextRef)
       if err != nil {
           return openapiserver.Response(http.StatusInternalServerError, nil), err
       }
       klog.Info(releaseCommand)
       n1MessageResponse = append(n1MessageResponse, releaseCommand...)


   }
   // Return a success response
   // Returns a `200 OK` response.
   // sessionContext := s.smcontextTable[smContextRef]


   if err != nil {
       span.RecordError(err)
       span.SetStatus(codes.Error, "Update failed")
   } else {
       span.SetStatus(codes.Ok, "Update successful")
   }


   return openapiserver.Response(http.StatusOK, openapiserver.SmContextUpdatedData{
       UpCnxState: session.State,
       N1SmMsg:    n1MessageResponse,
       // N1SmMsg:      smContextUpdateData.N1SmMsg,
       // N2SmInfo:     smContextUpdateData.N2SmInfo,
       N2SmInfoType: smContextUpdateData.N2SmInfoType,
   }), nil


}



I have shared the code files please go through these files and help me solve my errors.

What I feel is, if you look at the create function, you will understand what might be missing and why we are getting errors in update function as create function is working properly.
